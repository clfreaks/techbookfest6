
= エディタ「Lem」


LemはCommon Lispが動作するランタイム上のエディタです。



Common Lispでの拡張を想定しており、Common Lispの開発環境を主に提供しています。  それ以外にもLemの開発者が使う言語を中心にサポートしています。
操作体系は作者がemacsを使っていたこともあり、emacsによく似ていますが他のエディタにある機能も取り込むようにしており、vi(vim)のモードが用意されています。



また、メジャーなCommon Lisp処理系にあるイメージダンプ機能の利点を活かして、ライブラリの読み込み、メモリへのデータの配置状態を実行ファイルの形にしていて、高速に起動できる特徴もあります。


== Lemのインストール


LemをインストールするにはRoswellを使うのが簡単です。
次のコマンドでインストールできます。


//emlist{
$ ros install cxxxr/lem
//}


lemは256色をサポートしたターミナルで使うことを想定しています。
linuxのターミナルの場合、デフォルトでは8色しか表示できない事が多いのでTERM変数を変更してください。


//emlist{
$ export TERM=xterm-256color
//}

== Lemで使う用語


LemではEmacsと同じようにControlやMetaをプリフィクスとするコマンドを使います。



@<b>{C-} コントロールキーを押しっぱなしにして別のキーを打つことを意味します。



@<b>{M-} メタキーを押しっぱなしにして別のキーを打つことを意味します。メタキーはAltキーを使い、Macのターミナルでは設定でOptionキーに割り当てられます。



たとえば
@<tt>{C-x o}はControlを押しながらxを押したあと、Controlを離してoを押します。
@<tt>{C-x C-o}だとControlを押しながらxを押し、更にControlを押しながらoを押します。


=== ミニバッファ


画面の一番下で入力が出来る空間のことです。


=== バッファ


バッファはファイルと関連付けられたデータ構造を表します。


=== ウィンドウ


ウィンドウは一つのバッファを画面に表示するデータ構造を表します。


=== コマンド


コマンドはエディタを操作する機能です。
 カーソルを動かしたり文字を挿入する処理は一つのコマンドとして定義されます。
コマンドはキーに割り当てられたり@<tt>{M-x}の後、ミニバッファでコマンド名を入力することでも実行できます。
以後@<tt>{(M-x コマンド名)} と表記します。


== Lemの起動と終了


コマンドラインからLemを起動するにはlemコマンドを使います。
lemコマンドはRoswellからインストールしている場合に使えます。


//emlist{
$ lem [ファイル名]
//}


終了するには@<tt>{C-x C-c}と入力してください。


== 基本的な使い方


(TBD) 少し削ったものを作る。


== SLIME


SLIME(Superior Lisp Interaction Mode for Emacs)は元はEmacs上でCommon Lispの開発を行えるようにするEmacs用のプロダクトでした。
Common Lispランタイム上で動作するswnakサーバがあり、Emacs上のslimeとクライアントサーバ方式でswank rpcという独自プロトコルでやりとりを行い、パワルルなREPL、補完、デバッガ、インスペクタなどを提供します。
今もよく使われていますが、vimやatomなどのエディタでもslimeの実装が開発されていて、lemも同様にslimeを実装し、デフォルトでサポートしています。


=== lisp-mode


LemではCommon Lispの開発に便利な機能をlisp-modeとして提供し、内部でSLIMEを使っています。
lispファイルを開くか、明示的に@<tt>{M-x lisp-mode}とするかREPLが開かれるとlisp-modeが有効化されます。


=== SWANKサーバへの接続


lisp-modeが有効化されたときにSWANKサーバに接続していない場合は、自動でLemランタイム上でサーバを起動し、接続します。
LemはCommon Lispで書いているのでLemとSWANKサーバを同じランタイム上で動かせ、それをすることでLem自身の状態の変更をSLIMEの機能を介して行うことが出来ます。



REPLを開くには@<tt>{start-lisp-repl}コマンドを使います。


//emlist{
M-x start-lisp-repl
//}


lemとは別のプロセスを起動してSLIMEで接続するにはslimeコマンドを使います。
このコマンドはREPLも同時に開きます。


//emlist{
M-x slime
//}


@<tt>{C-u}を前に入力してslimeコマンドを使うと起動する処理系を選べます。


//emlist{
C-u M-x slime
//}

=== REPL


ためしに何か入力してみます。


//emlist{
CL-USER> (loop :for i :from 0 :below 100 :sum i)
5050
//}


REPLは基本的にコマンドラインからの使用と同じですがSLIMEで追加された機能があります。



履歴を辿るには@<tt>{M-p} @<tt>{M-n}で行えます。



現在のパッケージを切り替えるには@<tt>{(in-package パッケージ名)}を入力することでも出来ますが@<tt>{C-c M-p (M-x lisp-set-package)}でもREPLのパッケージを切り替えられます。



@<tt>{C-c M-o (M-x listener-clear-buffer)}でバッファをクリアできます。



@<tt>{C-c C-u (M-x listener-clear-input)}で現在の入力を消去します。



実行を中断したい場合は@<tt>{C-c C-c (M-x lisp-repl-interrupt)}です。


//emlist{
CL-USER> (loop)
;; C-c C-cで中断 デバッガでqを押してreplに戻る
CL-USER>
//}


中断すると割り込みエラーでデバッガが表示されます。
デバッガの使い方については後述します(TBD)


=== インデント


カーソルの行を字下げするにはTabを入力します。
一つの式をまとめてインデントするには@<tt>{C-M-q}です。


//emlist[][lisp]{
(defun fact (n)
(if (= n 0)
1
(* n (fact (1- n)))))
//}


ここで@<tt>{(defun}の先頭にカーソルを合わせて@<tt>{C-M-q}とすると次のようにインデントされます。


//emlist[][lisp]{
(defun fact (n)
  (if (= n 0)
      1
      (* n (fact (1- n)))))
//}


あとから追加されたマクロなどで特別なインデントをしたい場合は、そのマクロをSWANKサーバ側で定義さていると出来ます。
例えばcl-ppcreにregister-groups-bindというマクロがありますが、これはcl-ppcreを読み込んでない状態では関数と同じインデントにされてしまいます。


//emlist[][lisp]{
(ppcre:register-groups-bind (key value)
                            ("(\\w+):(\\w+)" "foo:bar")
                            (cons key value))
//}


cl-ppcreを読み込むと正しくインデントできます。


//emlist{
CL-USER> (ql:quickload :cl-ppcre)
//}

//emlist[][lisp]{
(ppcre:register-groups-bind (key value)
    ("(\\w+):(\\w+)" "foo:bar")
  (cons key value))
//}

=== 入力補完


Lemでは入力中にTabを押すことで補完が出来ます。



//image[02-lem-completion][]{
//}




このときに@<tt>{C-n}や@<tt>{M-n}、カーソルキーの下を入力すれば一つ下の候補を選べます。
上にするには@<tt>{C-p} @<tt>{M-p} カーソルキーの上を入力します。
Enterを押すことでその補完候補を選択できます。
@<tt>{lisp-modeではあいまい補完を使っているので並びがあっていれば補完候補に表示されます。
補完機能はミニバッファでの入力などでも出来るので、例えばファイルを開く(}C-x C-f`)場合はファイル名が補完されます。


=== 式の評価とコンパイル


lispファイル上の式を評価してみます。
例としてfoo.lispというファイルを開きます。


//emlist[][lisp]{
;;; foo.lisp

(defun foo (x)
  (1+ x))
//}


関数fooの中で@<tt>{C-M-x}とすると、そのdefunが評価され、定義されます。



REPLで定義した関数を呼びだしてみます。


//emlist[][lisp]{
CL-USER> (foo 0)
1
//}


@<tt>{C-M-x}の代わりに@<tt>{C-c C-c}を使うと評価ではなくコンパイルされロードされます。
コンパイルするとコンパイル時の警告部分が赤線で引かれます。
//image[02-lem-compile][]{
//}




コンパイル時に出てきたウィンドウにの指定箇所にカーソルを合わせてEnterを押すことで特定箇所にジャンプすることが出来ます。
@<tt>{C-x C-n}、@<tt>{C-x C-p}を使って順番に特定箇所にジャンプすることも可能です。
赤線を消すには警告箇所を修正して再度@<tt>{C-c C-c}します。
@<tt>{C-c M-c}をしてもバッファ内の全ての赤線を消すことが出来ます。
ファイル自体を読み込むには@<tt>{C-c C-l}をします。
コンパイルし、その結果を読み込むには@<tt>{C-c C-k}をします。
カーソルの前の式を評価するには@<tt>{C-c C-e}をします。


//emlist[][lisp]{
(progn
  (foo) ; <- (foo)だけ評価するにはここでC-c C-e
  (bar))
//}


ミニバッファに式を入力し、評価するには@<tt>{C-c M-:}とします。
評価中の式が無限ループをして終わらない場合などはREPLでの中断とは別に@<tt>{C-c g}をして中断ができます。
評価は基本的に現在接続しているSWANKサーバで行いますが、その接続しているプロセスとは別にLemのカスタマイズをしたいなどの理由でLemのプロセス内で評価するコマンドも用意しています。
カーソルの前の式をLemプロセス内で評価する場合は@<tt>{C-c C-e}の代わりに@<tt>{C-x C-e}、
ミニバッファで入力した式をLemプロセス内で評価する場合は@<tt>{C-c M-:}の代わりに@<tt>{M-:}を使います。


=== 定義へのジャンプ


ある関数や変数、クラスなどの定義位置を参照する機能があります。
@<tt>{M-. (M-x find-definitions)}を使うことでソースコードの適当箇所にジャンプすることができます。
カーソル位置にシンボルがある場合はその定義位置へジャンプし、無ければミニバッファからシンボル名を入力します。
元の位置に戻るには@<tt>{M-, (M-x pop-definition-stack)}を使います。



この機能はSWANKサーバ側でシンボルを参照するので、事前にそのシンボルが定義されているようにシステムを読み込んでおかなければなりません。


//emlist{
CL-USER> (ql:quickload システム名)
//}


適当する定義が複数ある場合は定義箇所にジャンプする前に一覧が別ウィンドウに表示されます。
次の画像はcl-ppcre:scanを対象にした例です。
//image[02-lem-jump-to-definitions][]{
//}




この場合は@<tt>{C-x C-n} @<tt>{C-x C-p}で定義箇所に順番にジャンプできます。
一覧が表示されたウィンドウに移動して見たい定義にカーソルを合わせてEnterを押すことでも定義位置にジャンプできます。
この操作方法はコンパイラの警告の一覧と同じす。この機能は他にもgrepなどで使われています。

